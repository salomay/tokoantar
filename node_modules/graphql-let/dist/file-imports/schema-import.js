"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appendFileSchemaContext = exports.createSchemaHashSync = exports.createSchemaHash = exports.shouldGenResolverTypes = void 0;
const fs_1 = require("fs");
const globby_1 = __importDefault(require("globby"));
const slash_1 = __importDefault(require("slash"));
const hash_1 = require("../lib/hash");
const paths_1 = require("../lib/paths");
const print_1 = require("../lib/print");
function shouldGenResolverTypes(config) {
    try {
        if (!config.schemaEntrypoint)
            return false;
        require('@graphql-codegen/typescript');
        require('@graphql-codegen/typescript-resolvers');
        const hasFilePointer = getSchemaPointers(config.schema).some((p) => !paths_1.isURL(p));
        if (!hasFilePointer) {
            print_1.printError(new Error(`To use Resolver Types, you should have at least one file in "schema".`));
            return false;
        }
        return true;
    }
    catch (e) {
        // Just skip.
        return false;
    }
}
exports.shouldGenResolverTypes = shouldGenResolverTypes;
function getSchemaPointers(schema, _acc = []) {
    if (typeof schema === 'string') {
        _acc.push(schema);
    }
    else if (Array.isArray(schema)) {
        for (const s of schema)
            getSchemaPointers(s, _acc);
    }
    else if (typeof schema === 'object') {
        for (const s of Object.keys(schema))
            getSchemaPointers(s, _acc);
    }
    return _acc;
}
function prepareCreateSchemaHashArgs(execContext) {
    const { config, configHash, cwd } = execContext;
    const schemaPointers = getSchemaPointers(config.schema);
    const filePointers = schemaPointers.filter((p) => !paths_1.isURL(p));
    return { configHash, cwd, filePointers };
}
async function createSchemaHash(execContext) {
    const { configHash, cwd, filePointers } = prepareCreateSchemaHashArgs(execContext);
    const files = await globby_1.default(filePointers, { cwd, absolute: true });
    const contents = files
        .map(slash_1.default)
        .sort()
        .map((file) => fs_1.readFileSync(file, 'utf-8'));
    return hash_1.createHashFromBuffers([configHash, ...contents]);
}
exports.createSchemaHash = createSchemaHash;
function createSchemaHashSync(execContext) {
    const { configHash, cwd, filePointers } = prepareCreateSchemaHashArgs(execContext);
    const files = globby_1.default.sync(filePointers, { cwd, absolute: true });
    const contents = files
        .map(slash_1.default)
        .sort()
        .map((file) => fs_1.readFileSync(file));
    return hash_1.createHashFromBuffers([configHash, ...contents]);
}
exports.createSchemaHashSync = createSchemaHashSync;
async function appendFileSchemaContext(execContext, codegenContext) {
    const { config, configHash } = execContext;
    // To pass config change on subsequent generation,
    // configHash should be primary hash seed.
    let schemaHash = configHash;
    if (shouldGenResolverTypes(config)) {
        schemaHash = await createSchemaHash(execContext);
        const createdPaths = paths_1.createPaths(execContext, config.schemaEntrypoint);
        const shouldUpdate = schemaHash !== hash_1.readHash(createdPaths.tsxFullPath) ||
            schemaHash !== hash_1.readHash(createdPaths.dtsFullPath);
        const context = {
            ...createdPaths,
            type: 'schema-import',
            gqlHash: schemaHash,
            skip: !shouldUpdate,
        };
        codegenContext.push(context);
    }
    return { schemaHash };
}
exports.appendFileSchemaContext = appendFileSchemaContext;
