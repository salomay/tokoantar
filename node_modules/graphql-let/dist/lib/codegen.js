"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processCodegenForContext = exports.buildCodegenConfig = void 0;
const cli_1 = require("@graphql-codegen/cli");
const make_dir_1 = __importDefault(require("make-dir"));
const path_1 = __importDefault(require("path"));
const file_1 = require("./file");
const hash_1 = require("./hash");
const print_1 = require("./print");
const types_1 = require("./types");
function buildCodegenConfig({ cwd, config }, codegenContext) {
    const generates = Object.create(null);
    for (const context of codegenContext) {
        if (context.skip)
            continue;
        const { tsxFullPath } = context;
        let opts;
        switch (context.type) {
            case 'schema-import':
                opts = {
                    plugins: ['typescript', 'typescript-resolvers'],
                };
                break;
            case 'document-import':
            case 'load-call':
                opts = {
                    plugins: config.plugins,
                    documents: context.gqlRelPath,
                };
                break;
            case 'gql-call':
                opts = {
                    plugins: config.plugins,
                    documents: context.resolvedGqlContent,
                };
                break;
        }
        generates[tsxFullPath] = {
            ...config.generateOptions,
            ...opts,
        };
    }
    return {
        ...config,
        // Regardless of `silent` value in config,
        // we always suppress GraphQL code generator logs
        silent: true,
        // @ts-ignore
        cwd,
        // @ts-ignore This allows recognizing "#import" in GraphQL documents
        skipGraphQLImport: false,
        // In our config, "documents" should always be empty
        // since "generates" should take care of them.
        documents: undefined,
        generates,
    };
}
exports.buildCodegenConfig = buildCodegenConfig;
async function processGraphQLCodegen(execContext, codegenContext, generateArg) {
    let results;
    try {
        results = await cli_1.generate(generateArg, false);
    }
    catch (error) {
        if (error.name === 'ListrError' && error.errors != null) {
            for (const err of error.errors) {
                err.message = `${err.message}${err.details}`;
                print_1.printError(err);
            }
        }
        else {
            print_1.printError(error);
        }
        throw error;
    }
    // Object option "generates" in codegen obviously doesn't guarantee result's order.
    const tsxPathTable = new Map(codegenContext.map((c) => [c.tsxFullPath, c]));
    for (const result of results) {
        const { filename, content } = result;
        const context = tsxPathTable.get(filename);
        if (!context)
            throw new Error('never');
        await make_dir_1.default(path_1.default.dirname(filename));
        await file_1.writeFile(filename, hash_1.withHash(context.gqlHash, content));
    }
    return results;
}
async function processCodegenForContext(execContext, codegenContext) {
    if (types_1.isAllSkip(codegenContext))
        return [];
    const codegenConfig = buildCodegenConfig(execContext, codegenContext);
    return await processGraphQLCodegen(execContext, codegenContext, codegenConfig);
}
exports.processCodegenForContext = processCodegenForContext;
